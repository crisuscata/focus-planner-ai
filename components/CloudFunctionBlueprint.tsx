import React from 'react';

export const CloudFunctionBlueprint: React.FC = () => {
  const code = `
/**
 * Focus Planner AI - Google Cloud Function Blueprint
 * 
 * Dependencies (package.json):
 * {
 *   "dependencies": {
 *     "@google-cloud/functions-framework": "^3.0.0",
 *     "googleapis": "^105.0.0",
 *     "firebase-admin": "^11.0.0",
 *     "date-fns": "^2.30.0"
 *   }
 * }
 */

const { google } = require('googleapis');
const admin = require('firebase-admin');
const { addMinutes, parseISO, isBefore, isAfter } = require('date-fns');

// Initialize Firebase Admin
admin.initializeApp();
const db = admin.firestore();

/**
 * Cloud Function to Schedule Focus Goal
 * Triggers: HTTP
 */
exports.scheduleFocusGoal = async (req, res) => {
  // 1. CORS & Auth Check (Simplified)
  res.set('Access-Control-Allow-Origin', '*');
  if (req.method === 'OPTIONS') {
    res.set('Access-Control-Allow-Methods', 'POST');
    res.set('Access-Control-Allow-Headers', 'Content-Type');
    res.status(204).send('');
    return;
  }

  try {
    const { title, durationMinutes, preference, date, userToken } = req.body;

    // 2. Auth: Initialize Calendar Client with User Token
    const auth = new google.auth.OAuth2();
    auth.setCredentials({ access_token: userToken });
    const calendar = google.calendar({ version: 'v3', auth });

    // 3. Logic: Determine Time Window based on Preference
    // (MaÃ±ana: 8-12, Tarde: 12-17, Noche: 17-21)
    let startHour = 8, endHour = 12;
    if (preference === 'AFTERNOON') { startHour = 12; endHour = 17; }
    if (preference === 'EVENING') { startHour = 17; endHour = 21; }

    const searchDate = parseISO(date); // e.g., '2023-10-27'
    const windowStart = new Date(searchDate); windowStart.setHours(startHour, 0, 0, 0);
    const windowEnd = new Date(searchDate); windowEnd.setHours(endHour, 0, 0, 0);

    // 4. Algorithm: Fetch Busy Slots
    const eventsRes = await calendar.events.list({
      calendarId: 'primary',
      timeMin: windowStart.toISOString(),
      timeMax: windowEnd.toISOString(),
      singleEvents: true,
      orderBy: 'startTime',
    });

    const busySlots = eventsRes.data.items || [];
    
    // 5. Algorithm: Find First Available Gap
    let proposedStart = new Date(windowStart);
    let foundSlot = null;

    // Iterate through the window in 15m increments (simplified)
    while (addMinutes(proposedStart, durationMinutes) <= windowEnd) {
      const proposedEnd = addMinutes(proposedStart, durationMinutes);
      
      const isBusy = busySlots.some(event => {
        const eventStart = new Date(event.start.dateTime || event.start.date);
        const eventEnd = new Date(event.end.dateTime || event.end.date);
        return (proposedStart < eventEnd && proposedEnd > eventStart);
      });

      if (!isBusy) {
        foundSlot = { start: proposedStart, end: proposedEnd };
        break;
      }
      proposedStart = addMinutes(proposedStart, 15);
    }

    // 6. Error Handling: Suggest Next Day (Simplified logic)
    if (!foundSlot) {
      return res.status(409).json({ 
        message: 'No slot found today. Suggesting next day...',
        suggestedDate: addMinutes(windowStart, 24 * 60) 
      });
    }

    // 7. Get Motivational Quote from Firestore
    // Collection: 'quotes' -> Document with fields { text: string }
    const quotesSnapshot = await db.collection('quotes').get();
    const quotes = quotesSnapshot.docs.map(doc => doc.data().text);
    const randomQuote = quotes[Math.floor(Math.random() * quotes.length)] || "Stay focused!";

    // 8. Create Event
    const event = {
      summary: \`ðŸŽ¯ Focus: \${title}\`,
      description: \`Motivation: "\${randomQuote}"\\nGenerated by Focus Planner AI\`,
      start: { dateTime: foundSlot.start.toISOString() },
      end: { dateTime: foundSlot.end.toISOString() },
      reminders: {
        useDefault: false,
        overrides: [
          { method: 'popup', minutes: 10 }, // Requirement: 10 min popup
        ],
      },
    };

    const createdEvent = await calendar.events.insert({
      calendarId: 'primary',
      resource: event,
    });

    res.status(200).json({
      success: true,
      data: createdEvent.data,
      quote: randomQuote
    });

  } catch (error) {
    console.error(error);
    res.status(500).json({ error: error.message });
  }
};
`;

  return (
    <div className="bg-slate-900 rounded-lg p-6 shadow-xl text-left overflow-hidden">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-slate-100 font-semibold flex items-center gap-2">
          <svg className="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
          </svg>
          Google Cloud Function Blueprint (Node.js)
        </h3>
        <span className="text-xs text-slate-400 px-2 py-1 bg-slate-800 rounded">backend/index.js</span>
      </div>
      <div className="overflow-x-auto">
        <pre className="text-xs md:text-sm font-mono text-blue-300 leading-relaxed">
          {code}
        </pre>
      </div>
    </div>
  );
};